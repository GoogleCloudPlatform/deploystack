

# INPUT COLLECTION
function collectParamters() {
    local __resultvar=$1
    local ARG=$2
    local VALUE=$2
    local LABEL=$3
    local DEFAULT=$4

    if [[ $ARG ]]; then
        VALUE=$ARG
    else
        # Allow user to overide the VALUE.
        printf "Enter $LABEL"
        if [[ $DEFAULT ]]; then
            VALUE=$DEFAULT
            printf " [leave blank for ${CYAN}'${DEFAULT}'${NC}]"
        fi
        printf ": "
        read USER_VALUE

        if [[ $USER_VALUE ]]; then
            VALUE=$USER_VALUE
        fi

    fi

    if [[ !($VALUE) ]]; then
        printf "\n${BRED}Sorry, $LABEL is mandatory.${NC}\n"
        exit 1
    fi

    eval $__resultvar="'$VALUE'"
}

function collectAddressInfo() {
    local __resultvar=$1
    local LABEL=$2
    local VALUE="$3"
    local NOTE=$4

    printf "Enter your $LABEL"

    if [[ "$VALUE" != "" ]]; then
        printf " [leave blank for ${CYAN}'${VALUE}'${NC}]"
    fi

    printf "\n"

    if [[ $NOTE ]]; then
        printf "${ONCYAN}NOTE:${CYAN} $NOTE${NC}\n"
    fi

    printf ":"

    read USER_VALUE

    if [[ $USER_VALUE ]]; then
        VALUE="$USER_VALUE"
    fi

    if [[ !($VALUE) ]]; then
        printf "\n${BRED}Sorry, $LABEL is mandatory.${NC}\n"
        exit 1
    fi

    eval $__resultvar="'$VALUE'"
}


# GCP PROJECT MANAGEMENT
function handleProject {
    local __resultvar=$1
    local ARG=$2
    local VALUE

    if [[ $ARG ]]; then
        VALUE=$ARG
    else
        selectProject VALUE
    fi
    
    if [[ -z "${OUTPUTFILE}" ]]
    then
        printf "gcloud config set project ${VALUE}\n" >> $OUTPUTFILE
    fi
    
    eval $__resultvar="'$VALUE'"
}

function createProject() {
    local __resultvar=$1
    local ANSWER
    local PROPOSED_PROJECT_ID
    local BA
    local SUCCESS="false"

    section_open "Creating the project"
    while [ "$SUCCESS" == "false" ]; do
        SUCCESS="true"
        printf "${BCYAN}Please enter a new project name to create: ${NC}\n"
        read PROPOSED_PROJECT_ID
        gcloud projects create $PROPOSED_PROJECT_ID --set-as-default || SUCCESS="false"

        if [ "$SUCCESS" == "false" ]; then
            printf "${ONRED}Project name could not be created, please choose another${NC}\n"
            continue
        fi
    done
    gcloud config set project ${PROPOSED_PROJECT_ID}
    section_close

    determineBillingAccount BA

    section_open "Activating Billing for the project"
    gcloud beta billing projects link $PROPOSED_PROJECT_ID --billing-account=$BA
    section_close
    eval $__resultvar="'$PROPOSED_PROJECT_ID'"
}

function determineBillingAccount() {
    local __resultvar=$1
    BA_LIST_GCLOUD=$(gcloud beta billing accounts list --format="value(ACCOUNT_ID)" | xargs)
    IFS=$'\n' read -rd '' -a BA_LIST <<<"$BA_LIST_GCLOUD"

    if [ ${#BA_LIST[@]} == 1 ]; then
        BA=$BA_LIST_GCLOUD
    else
        printf "${BCYAN}Choose Billing Account from this list${NC}: "
        gcloud beta billing accounts list

        select opt in "${BA_LIST[@]}"; do
            BA=$opt
            break
        done
    fi

    eval $__resultvar="'$BA'"

}

function selectProject() {
    local __resultvar=$1
    local PROJ
    local CURRPROJ
    local CREATESTRING="[CREATE NEW PROJECT]"

    get_project_id CURRPROJ

    if [[ !($CURRPROJ) ]]; then
        CURRPROJ="$CREATESTRING"
    fi

    PROJECT_LIST_GCLOUD=$(gcloud projects list --format="value(PROJECT_ID)")
    IFS=$'\n' read -rd '' -a PROJECTS <<<"$PROJECT_LIST_GCLOUD"
    PROJECTS=($(for l in ${PROJECTS[@]}; do echo $l; done | sort))
    PROJECTS=("$CREATESTRING" ${PROJECTS[@]})

    printf "\n${BCYAN}Choose a project to use for this application. ${NC}\n\n"
    printf "${ONCYAN}NOTE:${CYAN}: This app will make changes to the project. ${NC}\n"
    printf "While those changes are reverseable, it would be better to put it in a fresh new project. \n"

    opt=$(selectWithDefault "$CURRPROJ" "${PROJECTS[@]}")
    if [[ "$opt" == "$CREATESTRING" ]]; then
        createProject PROJ
    else
        PROJ=$opt
        gcloud config set project ${PROJ}
    fi

    eval $__resultvar="'$PROJ'"
}





# FLOW CONTROL
function await_command() {
    local __resultvar=$1
    local DURATION=$2
    local limit=$3
    local OP=$4
    local NAME=$5
    local REGION=$6
    local DOMAIN=$5
    local IP=$6

    case $OP in
    "sqlIP")
        COMMAND="gcloud beta sql instances describe"
        FORMAT="--format='value(ipAddresses[0].ipAddress)'"
        MESSAGE="Checking if IP is available"
        AWAITING="!BLANK"
        ERROREXPECTED=false
        ;;

    "sqlREADY")
        COMMAND="gcloud beta sql instances describe"
        FORMAT="--format='value(state)'"
        MESSAGE="Checking if database is up"
        AWAITING="RUNNABLE"
        ERROREXPECTED=false
        ;;

    "redisIP")
        COMMAND="gcloud redis instances describe"
        FORMAT="--region=$REGION --format='value(host)'"
        MESSAGE="Checking if IP is available"
        AWAITING="!BLANK"
        ERROREXPECTED=false
        ;;

    "redisGone")
        COMMAND="gcloud redis instances describe"
        FORMAT="--region=$REGION --format='value(host)'"
        MESSAGE="Checking if Redis server is gone"
        AWAITING=""
        ERROREXPECTED=true
        ;;

    "domainREADY")
        COMMAND="gcloud beta domains registrations describe"
        FORMAT="--format='value(state)'"
        MESSAGE="Checking if domain is active "
        AWAITING="ACTIVE"
        ERROREXPECTED=false
        ;;

    "url200")
        COMMAND="curl --write-out '%{http_code}' --resolve $DOMAIN:80:$IP --silent --output /dev/null http://$DOMAIN"
        FORMAT=""
        MESSAGE="Checking if url is returning STATUS OK "
        AWAITING=200
        NAME=""
        ERROREXPECTED=false
        ;;

    *)
        echo "Unknown Operation Type"
        exit 1
        ;;
    esac

    ERROR=false
    VALUE=$(eval $COMMAND $NAME $FORMAT) || ERROR=true

    if [ "$ERROR" = true ]; then
        if [ "$ERROREXPECTED" == true ]; then
            printf "\n"
            eval $__resultvar=""
            return 1
        fi
        printf "Command to poll errored. Exiting\n"
        return 1
    fi

    i=0
    if [ "$AWAITING" = "!BLANK" ]; then
        while [ "$VALUE" = "" ]; do

            i=$(($i + 1))
            if [ $i -eq 1 ]; then
                printf $MESSAGE
            fi

            if [ $i -eq $limit ]; then
                printf "Timed out \n"
                return 1
            fi

            VALUE=$(eval $COMMAND $NAME $FORMAT) || ERROR=true
            if [ "$ERROR" = true ]; then
                if [ "$ERROREXPECTED" == true ]; then
                    printf "\n"
                    eval $__resultvar="''"
                    return 1
                fi
                printf "Command to poll errored. Exiting\n"
                return 1
            fi
            printf "."
            sleep $DURATION
        done
    else
        while [ "$VALUE" != "$AWAITING" ]; do
            i=$(($i + 1))
            if [ $i -eq 1 ]; then
                printf $MESSAGE
            fi

            if [ $i -eq $limit ]; then
                printf "Timed out \n"
                return 1
            fi

            VALUE=$(eval $COMMAND $NAME $FORMAT) || ERROR=true

            if [ "$ERROR" = true ]; then
                if [ "$ERROREXPECTED" == true ]; then
                    printf "\n"
                    eval $__resultvar="''"
                    return 1
                fi
                printf "Command to poll errored. Exiting\n"
                return 1
            fi
            printf "."
            sleep $DURATION
        done
    fi
    printf "\n"
    eval $__resultvar="'$VALUE'"
}

# TEST HELP
function evalTest() {
    local command=$1
    local expected=$2

    local ERR=""
    got=$(eval $command 2>errFile)
    ERR=$(<errFile)

    if [ ${#ERR} -gt 0 ]; then
        if [ "$expected" = "EXPECTERROR" ]; then
            printf "Expected Error thrown \n"
            return
        fi

        printf "Halting - error: '$ERR'  \n"
        exit 1
    fi

    if [ "$got" != "$expected" ]; then
        printf "Halting: '$got'  \n"
        exit 1
    fi

    printf "$expected is ok\n"
}

function randomString() {
    local __resultvar=$1
    local VALUE=$(
        LC_ALL=C tr -dc 'a-z0-9' </dev/urandom | head -c 13
        echo
    )
    eval $__resultvar="'$VALUE'"
}

function prGcloud(){
    local prefix=$(which gcloud)
    local tmp=${1/gcloud/$prefix}

    local cmd="${tmp/\/\\}"
    local orig="${1/\/\\}"
    cmd=$(echo "${cmd//[$'\t\r\n']}")

    IFS=$'\n' read -rd '' -a cmdlines <<<"$orig"

    count=0
    for line in "${cmdlines[@]}"
    do
    :
    if [[ $count -lt   ${#cmdlines[@]}-1 ]]
    then
        printf "${BCYAN}$line${NC} \\ \n"
        if [[ -z "${OUTPUTFILE}" ]]
        then
           echo "$line \\" >> $OUTPUTFILE
        fi
        
    else
        printf "${BCYAN}$line${NC} \n"
        if [[ -z "${OUTPUTFILE}" ]]
        then
            echo "$line " >> $OUTPUTFILE
        fi
    fi
    count=$[count + 1]
    done
    
    eval "${cmd}"
}
